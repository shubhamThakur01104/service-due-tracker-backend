import csv from "csv-parser";
import xlsx from "xlsx";
import { Readable } from "stream";
import { Customer } from "../models/customer.model.js";
import { Unit } from "../models/unit.model.js";

export const importCustomersAndUnits = async (fileBuffer) => {
    const buffer = Buffer.from(fileBuffer);
    const results = [];

    // Check if file is Excel (XLSX/XLS) or CSV by attempting to parse
    const isExcelFile = () => {
        try {
            // Try to detect if it's an Excel file
            const firstBytes = buffer.slice(0, 8);
            const header = firstBytes.toString('hex');

            // Excel files typically start with PK (ZIP format for .xlsx) or specific Excel signatures
            if (header.startsWith('504b')) return true; // .xlsx files

            // Also check if it looks like Excel by checking for common Excel headers
            const firstChunk = buffer.slice(0, 100).toString();
            if (firstChunk.includes('xl/') || firstChunk.includes('workbook') || firstChunk.includes('sheet')) {
                return true;
            }

            return false;
        } catch (error) {
            return false;
        }
    };

    if (isExcelFile()) {
        // Parse Excel file
        const workbook = xlsx.read(buffer, { type: 'buffer' });
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        const jsonData = xlsx.utils.sheet_to_json(worksheet);

        jsonData.forEach(row => results.push(row));
    } else {
        // Parse CSV file
        await new Promise((resolve, reject) => {
            const stream = Readable.from(buffer);
            stream
                .pipe(csv())
                .on("data", (row) => results.push(row))
                .on("end", resolve)
                .on("error", reject);
        });
    }

    let customersCreated = 0;
    let unitsCreated = 0;

    for (const row of results) {
        // Map fields from the Excel file (generated by datagenerator.py)
        const {
            name,           // Customer name
            phone,          // Customer phone
            displayName,    // Unit display name
            type,           // Unit type (AC, Heater, Machine, Generator)
            nextServiceDate,// Next service date
            email,          // Customer email (optional)
            houseNumber,    // Customer address (optional)
            street,         // Customer address (optional)
            city,           // Customer address (optional)
            state,          // Customer address (optional)
            pincode,        // Customer address (optional)
            lastServiceDate // Last service date (optional)
        } = row;

        // Calculate service interval days automatically
        let serviceIntervalDays = null;
        if (lastServiceDate && nextServiceDate) {
            try {
                const lastDate = new Date(lastServiceDate);
                const nextDate = new Date(nextServiceDate);
                if (!isNaN(lastDate.getTime()) && !isNaN(nextDate.getTime())) {
                    const diffTime = nextDate.getTime() - lastDate.getTime();
                    serviceIntervalDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                }
            } catch (error) {
                // If date parsing fails, leave serviceIntervalDays as null
                console.warn("Could not calculate service interval days for unit:", displayName);
            }
        }

        // Skip invalid rows - require name, phone, type, displayName, and nextServiceDate
        if (!name || !phone || !type || !displayName || !nextServiceDate) continue;

        // 1️⃣ Find or create customer
        let customer = await Customer.findOne({
            $or: [{ email }, { phone }]
        });

        if (!customer) {
            customer = await Customer.create({
                name,
                email: email || undefined,
                phone,
                address: {
                    houseNumber: houseNumber || undefined,
                    street: street || undefined,
                    city: city || undefined,
                    state: state || undefined,
                    pincode: pincode || undefined
                }
            });
            customersCreated++;
        }

        // 2️⃣ Create unit linked to customer
        await Unit.create({
            customerId: customer._id,
            type,
            displayName,
            lastServiceDate: lastServiceDate || null,
            nextServiceDate,
            serviceIntervalDays: serviceIntervalDays || null
        });

        unitsCreated++;
    }

    return { customersCreated, unitsCreated };
};
